#if defined _supertanks_included
	#endinput
#endif
#define _supertanks_included
#include <sourcemod>
#include <sdkhooks>
#include <sdktools>
#define ST_PREFIX "[ST++]"
#define ST_NAME "Super Tanks++"
#define ST_AUTHOR "Psyk0tik (Crasher_3637)"
#define ST_DESCRIPTION "Super Tanks++ makes fighting Tanks great again!"
#define ST_VERSION "8.4"
#define ST_URL "https://forums.alliedmods.net/showthread.php?t=302140"
#define ST_LOCK "=="
#define ST_UNLOCK "!="
#define ST_APPEND_BAD_FILENAME 0
#define ST_APPEND_FILE_NOT_FOUND 1
#define ST_APPEND_BAD_HANDLE 2
#define ST_APPEND_SUCCESS 3
#define ST_FIND_BAD_FILENAME 10
#define ST_FIND_FILE_NOT_FOUND 11
#define ST_FIND_BAD_HANDLE 12
#define ST_FIND_NOT_FOUND 13
#define ST_FIND_SUCCESS 14
#define ST_CLEAN_FILE_NOT_FOUND 20
#define ST_CLEAN_BAD_HANDLE 21
#define ST_CLEAN_SUCCESS 22
#define ST_NO_CONFIG 30
#define ST_FORMAT_BAD_FILENAME 40
#define ST_FORMAT_SUCCESS 41

// Configs
static bool bCreateDirectory;
static bool bCreateFile;
static char sConfigFile[PLATFORM_MAX_PATH];
static char sRawFileName[PLATFORM_MAX_PATH];
static char sFolderPath[PLATFORM_MAX_PATH];
static Handle hPluginHandle;
static int iCreateDirectoryMode;
static int iLastFindResult;
static int iLastAppendResult;

stock int iST_GetFindResult()
{
	return iLastFindResult;
}

stock int iST_GetAppendResult()
{
	return iLastAppendResult;
}

stock void vST_CreateConfig(bool create)
{
	bCreateFile = create;
}

stock void vST_CreateDirectory(bool create, int mode = 511)
{
	bCreateDirectory = create;
	iCreateDirectoryMode = mode;
}

stock bool bST_GetCreateFile()
{
	return bCreateFile;
}

stock void vST_SetPlugin(Handle plugin)
{
	hPluginHandle = plugin;
}

stock Handle hST_GetPlugin()
{
	return hPluginHandle;
}

stock bool bST_Config(char[] file, char[] folder = "sourcemod/super_tanks++")
{
	Format(sConfigFile, sizeof(sConfigFile), "%s", file);
	strcopy(sRawFileName, sizeof(sRawFileName), file);
	strcopy(sFolderPath, sizeof(sFolderPath), folder);
	return iST_FormatConfig(sConfigFile, sizeof(sConfigFile), folder) == ST_FORMAT_SUCCESS;
}

stock bool bST_GetConfig(char[] buffer, int size)
{
	if (strlen(sConfigFile) > 0)
	{
		strcopy(buffer, size, sConfigFile);
		return true;
	}
	buffer[0] = '\0';
	return false;
}

stock ConVar cvST_ConVar(const char[] name, const char[] defaultValue, const char[] description = "", int flags = 0, bool hasMin = false, float min = 0.0, bool hasMax = false, float max = 0.0)
{
	if (!(flags & FCVAR_DONTRECORD) && strlen(sConfigFile) > 0)
	{
		iLastFindResult = -1;
		iLastAppendResult = -1;
		char sValue[64];
		iLastFindResult = iST_FindValue(name, sValue, sizeof(sValue), true);
		if (iLastFindResult == ST_FIND_NOT_FOUND || (iLastFindResult == ST_FIND_FILE_NOT_FOUND && bCreateFile))
		{
			iLastAppendResult = iST_Append(name, defaultValue, description, flags, hasMin, min, hasMax, max);
		}
	}
	return CreateConVar(name, defaultValue, description, flags, hasMin, min, hasMax, max);
}

stock void vST_ExecConfig()
{
	AutoExecConfig(!bCreateFile, sRawFileName, sFolderPath);
}

stock static int iST_FormatConfig(char[] buffer, int size, char[] folder = "sourcemod/super_tanks++")
{
	if (strlen(sConfigFile) < 1)
	{
		return ST_NO_CONFIG;
	}
	if (StrContains(sConfigFile, ".cfg") != -1 && strlen(sConfigFile) < 4)
	{
		return ST_FORMAT_BAD_FILENAME;
	}
	char sPathPrefix[PLATFORM_MAX_PATH];
	if (strlen(folder) > 0)
	{
		Format(sPathPrefix, sizeof(sPathPrefix), "cfg/%s/", folder);
		if (bCreateDirectory && !DirExists(sPathPrefix))
		{
			CreateDirectory(sPathPrefix, iCreateDirectoryMode);
		}
	}
	else
	{
		Format(sPathPrefix, sizeof(sPathPrefix), "cfg/");
	}
	char sFile[PLATFORM_MAX_PATH];
	sFile[0] = '\0';
	if (StrContains(buffer, sPathPrefix) != 0)
	{
		StrCat(sFile, sizeof(sFile), sPathPrefix);
	}
	StrCat(sFile, sizeof(sFile), sConfigFile);
	if (StrContains(sFile[strlen(sFile) - 4], ".cfg") != 0)
	{
		StrCat(sFile, sizeof(sFile), ".cfg");
	}
	strcopy(buffer, size, sFile);
	return ST_FORMAT_SUCCESS;
}

stock int iST_Append(const char[] name, const char[] defaultValue, const char[] description, int flags, bool hasMin, float min, bool hasMax, float max)
{
	if (strlen(sConfigFile) < 1)
	{
		return ST_NO_CONFIG;
	}
	char sFile[PLATFORM_MAX_PATH];
	strcopy(sFile, sizeof(sFile), sConfigFile);
	bool bFileExists = FileExists(sFile);
	if (bCreateFile || bFileExists)
	{
		File fFile = OpenFile(sFile, (bFileExists ? "a" : "w"));
		char sWrite[2048];
		if (fFile == null)
		{
			return ST_APPEND_BAD_HANDLE;
		}
		if (bCreateFile && !bFileExists)
		{
			fFile.WriteLine("// This file was auto-generated by Super Tanks++ v%s (%s)", ST_VERSION, ST_URL);
			GetPluginFilename(hPluginHandle, sWrite, sizeof(sWrite));
			Format(sWrite, sizeof(sWrite), "// ConVars for plugin \"%s\"", sWrite);
			fFile.WriteLine(sWrite);
		}
		fFile.WriteLine("\n");
		int iNewLines = iST_GetCharCountInStr('\n', description);
		if (iNewLines == 0)
		{
			Format(sWrite, sizeof(sWrite), "// %s", description);
			fFile.WriteLine(sWrite);
		}
		else
		{
			char[][] newlineBuf = new char[iNewLines + 1][2048];
			ExplodeString(description, "\n", newlineBuf, iNewLines + 1, 2048, false);
			for (int iLine; iLine <= iNewLines; iLine++)
			{
				if (strlen(newlineBuf[iLine]) > 0)
				{
					fFile.WriteLine("// %s", newlineBuf[iLine]);
				}
			}
		}
		fFile.WriteLine("// -");
		Format(sWrite, sizeof(sWrite), "// Default: \"%s\"", defaultValue);
		fFile.WriteLine(sWrite);
		if (hasMin)
		{		
			Format(sWrite, sizeof(sWrite), "// Minimum: \"%f\"", min);
			fFile.WriteLine(sWrite);
		}
		if (hasMax)
		{
			Format(sWrite, sizeof(sWrite), "// Maximum: \"%f\"", max);
			fFile.WriteLine(sWrite);
		}
		Format(sWrite, sizeof(sWrite), "%s \"%s\"", name, defaultValue);
		fFile.WriteLine(sWrite);
		delete fFile;		
		return ST_APPEND_SUCCESS;
	}
	return ST_APPEND_FILE_NOT_FOUND;
}

stock int iST_FindValue(const char[] cvar, char[] value, int size, bool caseSensitive = false)
{
	value[0] = '\0';
	if (strlen(sConfigFile) < 1)
	{
		return ST_NO_CONFIG;
	}
	char sFile[PLATFORM_MAX_PATH];
	strcopy(sFile, sizeof(sFile), sConfigFile);
	bool bFileExists = FileExists(sFile);
	if (bCreateFile && !bFileExists)
	{
		return ST_FIND_FILE_NOT_FOUND;
	}
	if (bFileExists)
	{
		File fFile = OpenFile(sFile, "r");
		int iValueStart;
		int iValueEnd;
		int iCvarEnd;
		char sConvar[64];
		char sValue[64];
		char sRead[2048];
		char sCopy[2048];
		if (fFile == null)
		{
			return ST_FIND_BAD_HANDLE;
		}
		while (!fFile.EndOfFile() && fFile.ReadLine(sRead, sizeof(sRead)))
		{
			if (IsCharSpace(sRead[0]) || sRead[0] == '/' || (!IsCharNumeric(sRead[0]) && !IsCharAlpha(sRead[0])) || iST_GetCharCountInStr(' ', sRead) < 1 || iST_GetCharCountInStr('"', sRead) != 2 || (iValueStart = StrContains(sRead, "\"")) == -1 || (iValueEnd = StrContains(sRead[iValueStart+1], "\"")) == -1 || (iCvarEnd = StrContains(sRead, " ")) == -1 || iCvarEnd >= iValueStart || iCvarEnd >= iValueStart)
			{
				continue;
			}
			strcopy(sCopy, sizeof(sCopy), sRead);
			sCopy[iCvarEnd] = '\0';
			strcopy(sConvar, sizeof(sConvar), sCopy);
			strcopy(sCopy, sizeof(sCopy), sRead[iValueStart+1]);
			sCopy[iValueEnd] = '\0';
			strcopy(sValue, sizeof(sValue), sCopy);
			if (StrEqual(sConvar, cvar, caseSensitive))
			{
				Format(value, size, "%s", sConvar);
				delete fFile;
				return ST_FIND_SUCCESS;
			}					
		}
		delete fFile;	
		return ST_FIND_NOT_FOUND;
	}
	return ST_FIND_FILE_NOT_FOUND;
}

stock int iST_Clean()
{
	if (strlen(sConfigFile) < 1)
	{
		return ST_NO_CONFIG;
	}
	char sFile[PLATFORM_MAX_PATH];
	strcopy(sFile, sizeof(sFile), sConfigFile);
	if (!FileExists(sFile))
	{
		return ST_CLEAN_FILE_NOT_FOUND;
	}
	char sFile2[PLATFORM_MAX_PATH];
	Format(sFile2, sizeof(sFile2), "%s_tempcopy", sFile);
	char sRead[2048];
	int iCount;
	bool bFirstReached;
	File fFile1 = OpenFile(sFile, "r");
	File fFile2 = OpenFile(sFile2, "w");
	if (fFile1 == null || fFile2 == null)
	{
		if (fFile1 != null)
		{
			delete fFile1;
		}
		if (fFile2 != null)
		{
			delete fFile2;
		}
		return ST_CLEAN_BAD_HANDLE;
	}
	while (!fFile1.EndOfFile() && fFile1.ReadLine(sRead, sizeof(sRead)))
	{
		if (IsCharSpace(sRead[0]))
		{
			iCount++;
		}
		else
		{
			iCount = 0;
		}
		if (iCount < 2 || !bFirstReached)
		{
			ReplaceString(sRead, sizeof(sRead), "\n", "");
			fFile2.WriteLine(sRead);
		}
		if (iCount == 2)
		{
			bFirstReached = true;
		}
	}
	delete fFile1;
	delete fFile2;
	DeleteFile(sFile);
	RenameFile(sFile, sFile2);	
	return ST_CLEAN_SUCCESS;
}

stock static int iST_GetCharCountInStr(int character, const char[] str)
{
	int iLength = strlen(str);
	int iCount;
	for (int iString; iString < iLength; iString++)
	{
		if (str[iString] == character)
		{
			iCount++;
		}
	}
	return iCount;
}

// Checks
stock bool bHasIdlePlayer(int client)
{
	int iIdler = GetClientOfUserId(GetEntData(client, FindSendPropInfo("SurvivorBot", "m_humanSpectatorUserID")));
	if (iIdler)
	{
		if (IsClientInGame(iIdler) && !IsFakeClient(iIdler) && (GetClientTeam(iIdler) != 2))
		{
			return true;
		}
	}
	return false;
}

stock bool bIsBotIdle(int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2 && IsPlayerAlive(client) && !IsClientInKickQueue(client) && IsFakeClient(client) && bHasIdlePlayer(client);
}

stock bool bIsBotIdleSurvivor(int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2 && IsPlayerAlive(client) && !IsClientInKickQueue(client) && IsFakeClient(client) && !bHasIdlePlayer(client);
}

stock bool bIsBotInfected(int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3 && IsPlayerAlive(client) && !IsClientInKickQueue(client) && IsFakeClient(client);
}

stock bool bIsBotSurvivor(int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2 && IsPlayerAlive(client) && !IsClientInKickQueue(client) && IsFakeClient(client);
}

stock bool bIsFinaleMap()
{
	return FindEntityByClassname(-1, "trigger_finale") != -1;
}

stock bool bIsHumanSurvivor(int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2 && IsPlayerAlive(client) && !IsClientInKickQueue(client) && !IsFakeClient(client) && !bHasIdlePlayer(client) && !bIsPlayerIdle(client);
}

stock bool bIsIdlePlayer(int bot, int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && !IsFakeClient(client) && GetClientTeam(bot) == 2;
}

stock bool bIsInfected(int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3 && IsPlayerAlive(client) && !IsClientInKickQueue(client);
}

stock bool bIsL4D2Game()
{
	EngineVersion evEngine = GetEngineVersion();
	return evEngine == Engine_Left4Dead2;
}

stock bool bIsPlayerBurning(int client)
{
	float flBurnPercent = GetEntPropFloat(client, Prop_Send, "m_burnPercent");
	if (flBurnPercent > 0)
	{
		return true;
	}
	return false;
}

stock bool bIsPlayerGhost(int client)
{
	if (GetEntProp(client, Prop_Send, "m_isGhost", 1))
	{
		return true;
	}
	return false;
}

stock bool bIsPlayerIdle(int client)
{
	for (int iPlayer = 1; iPlayer <= MaxClients; iPlayer++)
	{
		if (!IsClientInGame(iPlayer) || GetClientTeam(iPlayer) != 2 || !IsFakeClient(iPlayer) || !bHasIdlePlayer(iPlayer))
		{
			continue;
		}
		int iIdler = GetClientOfUserId(GetEntData(iPlayer, FindSendPropInfo("SurvivorBot", "m_humanSpectatorUserID")));
		if (iIdler == client)
		{
			return true;
		}
	}
	return false;
}

stock bool bIsSpecialInfected(int client)
{
	char sClassname[32];
	if (bIsInfected(client))
	{
		GetEntityNetClass(client, sClassname, sizeof(sClassname));
		if (StrEqual(sClassname, "Smoker", false) || StrEqual(sClassname, "Boomer", false) || StrEqual(sClassname, "Hunter", false) || StrEqual(sClassname, "Spitter", false) || StrEqual(sClassname, "Jockey", false) || StrEqual(sClassname, "Charger", false))
		{
			return true;
		}
	}
	return false;
}

stock bool bIsSurvivor(int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2 && IsPlayerAlive(client) && !IsClientInKickQueue(client);
}

stock bool bIsSystemValid(ConVar convar, ConVar convar2, ConVar convar3)
{
	char sGameMode[32];
	char sConVarModes[32];
	convar.GetString(sGameMode, sizeof(sGameMode));
	Format(sGameMode, sizeof(sGameMode), ",%s,", sGameMode);
	convar2.GetString(sConVarModes, sizeof(sConVarModes));
	if (strcmp(sConVarModes, ""))
	{
		Format(sConVarModes, sizeof(sConVarModes), ",%s,", sConVarModes);
		if (StrContains(sConVarModes, sGameMode, false) == -1)
		{
			return false;
		}
	}
	convar3.GetString(sConVarModes, sizeof(sConVarModes));
	if (strcmp(sConVarModes, ""))
	{
		Format(sConVarModes, sizeof(sConVarModes), ",%s,", sConVarModes);
		if (StrContains(sConVarModes, sGameMode, false) != -1)
		{
			return false;
		}
	}
	return true;
}

stock bool bIsTank(int client)
{
	char sClassname[32];
	if (bIsInfected(client))
	{
		GetEntityNetClass(client, sClassname, sizeof(sClassname));
		if (StrEqual(sClassname, "Tank", false))
		{
			return true;
		}
	}
	return false;
}

stock bool bIsValidClient(int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && !IsClientInKickQueue(client);
}

stock bool bIsValidEntRef(int entity)
{
	return entity && EntRefToEntIndex(entity) != INVALID_ENT_REFERENCE;
}

public bool bTraceRayDontHitSelf(int entity, int mask, any data)
{
	if (entity == data) 
	{
		return false; 
	}
	else if (entity > 0 && entity <= MaxClients)
	{
		if (IsClientInGame(entity))
		{
			return false;
		}
	}
	return true;
}

// Functions
public float flGetGroundUnits(int entity)
{
	if (!(GetEntityFlags(entity) & FL_ONGROUND))
	{ 
		Handle hTrace;
		float flOrigin[3];
		float flPosition[3];
		float flDown[3] = {90.0, 0.0, 0.0};
		GetEntPropVector(entity, Prop_Send, "m_vecOrigin", flOrigin);
		hTrace = TR_TraceRayFilterEx(flOrigin, flDown, CONTENTS_SOLID|CONTENTS_MOVEABLE, RayType_Infinite, bTraceRayDontHitSelf, entity);
		if (TR_DidHit(hTrace))
		{
			float flUnits;
			TR_GetEndPosition(flPosition, hTrace);
			flUnits = flOrigin[2] - flPosition[2];
			delete hTrace;
			return flUnits;
		}
		delete hTrace;
	}
	return 0.0;
}

stock int iGetAccurateTime(ConVar convar, const bool difference = true)
{
	if (!difference)
	{
		return GetTime();
	}
	int iTime = GetTime();
	int iOperand = iParseTimeOffsetOperation(convar, false);
	int iAmount = iParseTimeOffsetOperation(convar, true);
	if (iOperand == '+')
	{
		iTime = iTime + (iAmount * 3600);
	}
	if (iOperand == '-')
	{
		iTime = iTime - (iAmount * 3600);
	}
	return iTime;
}

stock int iGetBotSurvivor()
{
	for (int iBot = MaxClients; iBot >= 1; iBot--)
	{
		if (bIsBotSurvivor(iBot))
		{
			return iBot;
		}
	}
	return -1;
}

stock int iGetHumanCount()
{
	int iHumanCount;
	for (int iHuman = 1; iHuman <= MaxClients; iHuman++)
	{
		if (bIsHumanSurvivor(iHuman))
		{
			iHumanCount++;
		}
	}
	return iHumanCount;
}

stock int iGetIdleBot(int client)
{
	for (int iBot = 1; iBot <= MaxClients; iBot++)
	{
		if (iGetIdlePlayer(iBot) == client)
		{
			return iBot;
		}
	}
	return 0;
}

stock int iGetIdlePlayer(int client)
{
	if (bIsBotSurvivor(client))
	{
		char sClassname[12];
		GetEntityNetClass(client, sClassname, sizeof(sClassname));
		if (strcmp(sClassname, "SurvivorBot") == 0)
		{
			int iIdler = GetClientOfUserId(GetEntProp(client, Prop_Send, "m_humanSpectatorUserID"));			
			if (iIdler > 0 && IsClientInGame(iIdler) && GetClientTeam(iIdler) == 1)
			{
				return iIdler;
			}
		}
	}
	return 0;
}

stock int iGetInfectedCount()
{
	int iInfectedCount;
	for (int iInfected = 1; iInfected <= MaxClients; iInfected++)
	{
		if (bIsInfected(iInfected))
		{
			iInfectedCount++;
		}
	}
	return iInfectedCount;
}

stock int iGetNearestSurvivor(int client)
{
	float flDistance = 0.0;
	float flNearest = 0.0;
	float flPlayerPos[3];
	float flTargetPos[3];
	if (bIsValidClient(client))
	{
		GetClientAbsOrigin(client, flPlayerPos);
		for (int iSurvivor = 1; iSurvivor <= MaxClients; iSurvivor++)
		{
			if (bIsSurvivor(iSurvivor))
			{
				GetClientAbsOrigin(iSurvivor, flTargetPos);
				flDistance = GetVectorDistance(flPlayerPos, flTargetPos);
				if (flNearest == 0.0 || flNearest > flDistance)
				{
					flNearest = flDistance;
				}
			}
		}
	}
	return RoundFloat(flDistance);
}

stock int iGetPlayerCount()
{
	int iPlayerCount;
	for (int iPlayer = 1; iPlayer <= MaxClients; iPlayer++)
	{
		if (bIsValidClient(iPlayer))
		{
			iPlayerCount++;
		}
	}
	return iPlayerCount;
}

stock int iGetRandomSurvivor()
{
    int iSurvivorCount;
    int iSurvivors[MAXPLAYERS + 1];
    for (int iSurvivor = 1; iSurvivor <= MaxClients; iSurvivor++)
    {
        if (bIsSurvivor(iSurvivor))
        {
            iSurvivors[iSurvivorCount++] = iSurvivor; 
        }
    }
    return iSurvivors[GetRandomInt(0, iSurvivorCount - 1)];
}

stock int iGetRayHitPos(float pos[3], float angle[3], float hitpos[3], int entity = 0, bool offset = false)
{
	int iHit = 0;
	Handle hTrace = TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, bTraceRayDontHitSelf, entity);
	if (TR_DidHit(hTrace))
	{
		TR_GetEndPosition(hitpos, hTrace);
		iHit = TR_GetEntityIndex(hTrace);
	}
	delete hTrace;
	if (offset)
	{
		float flVector[3];
		MakeVectorFromPoints(hitpos, pos, flVector);
		NormalizeVector(flVector, flVector);
		ScaleVector(flVector, 15.0);
		AddVectors(hitpos, flVector, hitpos);
	}
	return iHit;
}

stock int iGetRGBColor(int red, int green, int blue) 
{
	return (blue * 65536) + (green * 256) + red;
}

stock int iGetSurvivorCount()
{
	int iSurvivorCount;
	for (int iSurvivor = 1; iSurvivor <= MaxClients; iSurvivor++)
	{
		if (bIsSurvivor(iSurvivor))
		{
			iSurvivorCount++;
		}
	}
	return iSurvivorCount;
}

stock int iGetSurvivorRange(int client)
{
	int iSurvivorCount;
	for (int iSurvivor = 1; iSurvivor <= MaxClients; iSurvivor++)
	{
		if (bIsSurvivor(iSurvivor))
		{
			float flPlayerPos[3];
			float flTankPos[3];
			GetClientAbsOrigin(iSurvivor, flPlayerPos);
			GetClientAbsOrigin(client, flTankPos);
			float flDistance = GetVectorDistance(flTankPos, flPlayerPos);
			if (flDistance > 120)
			{
				iSurvivorCount++;
			}
		}
	}
	return iSurvivorCount;
}

stock int iGetTankCount()
{
	int iTankCount;
	for (int iTank = 1; iTank <= MaxClients; iTank++)
	{
		if (bIsTank(iTank))
		{
			iTankCount++;
		}
	}
	return iTankCount;
}

stock int iParseTimeOffsetOperation(ConVar convar, const bool operation = false)
{
	char sConvarValue[16];
	convar.GetString(sConvarValue, sizeof(sConvarValue));
	TrimString(sConvarValue);
	int iOperand = sConvarValue[0];
	sConvarValue[0] = ' ';
	TrimString(sConvarValue);
	int iAmount = StringToInt(sConvarValue);
	if (iOperand != '+' && iOperand != '-' && (iAmount <= 0 || iAmount > 24))
	{
		iOperand = ' ';
		iAmount  = 0;
	}
	return operation ? iAmount : iOperand;
}

stock void vCheatCommand(int client, char[] command, char[] arguments = "")
{
	int iCmdFlags = GetCommandFlags(command);
	SetCommandFlags(command, iCmdFlags & ~FCVAR_CHEAT);
	FakeClientCommand(client, "%s %s", command, arguments);
	SetCommandFlags(command, iCmdFlags | FCVAR_CHEAT);
}

stock void vDeleteEntity(int entity, float time)
{
	if (bIsValidEntRef(entity))
	{
		char sVariant[64];
		Format(sVariant, sizeof(sVariant), "OnUser1 !self:kill::%f:1", time);
		SetVariantString(sVariant);
		AcceptEntityInput(entity, "AddOutput");
		AcceptEntityInput(entity, "FireUser1");
	}
}

stock void vDeleteExplosion(int entity, float time, char[] input)
{
	if (bIsValidEntRef(entity))
	{
		char sVariant[64];
		Format(sVariant, sizeof(sVariant), "OnUser1 !self:kill::%f:1", time);
		SetVariantString(sVariant);
		AcceptEntityInput(entity, input);
	}
}

stock void vKickFakeClient(int client)
{
	if (IsFakeClient(client))
	{
		KickClient(client);
	}
}

stock void vSetPlayerAlive(int client, bool alive)
{
	alive ? SetEntData(client, FindSendPropInfo("CTransitioningPlayer", "m_isAlive"), 1, 1, true) : SetEntData(client, FindSendPropInfo("CTransitioningPlayer", "m_isAlive"), 0, 1, true);
}

stock void vSetPlayerGhost(int client, bool ghost)
{
	ghost ? SetEntProp(client, Prop_Send, "m_isGhost", 1, 1) : SetEntProp(client, Prop_Send, "m_isGhost", 0, 1);
}

stock void vSetPlayerLifeState(int client, bool ready)
{
	ready ? SetEntProp(client, Prop_Data, "m_lifeState", 1, 1) : SetEntProp(client, Prop_Data, "m_lifeState", 0, 1);
}

stock void vSpawnInfected(int client, int type, bool auto = true)
{
	bool[] bResetGhostState = new bool[MaxClients + 1];
	bool[] bResetAlive = new bool[MaxClients + 1];
	bool[] bResetLifeState = new bool[MaxClients + 1];
	ChangeClientTeam(client, 3);
	char sInfectedTypes[10][10] = {"", "smoker", "boomer", "hunter", "spitter", "jockey", "charger", "witch", "tank", "survivor"};
	char sOptions[32];
	if (type < 1 || type > 8 || !IsClientInGame(client) || GetClientTeam(client) != 3 || IsPlayerAlive(client))
	{
		return;
	}
	for (int iPlayer = 1; iPlayer <= MaxClients; iPlayer++)
	{ 
		if (iPlayer == client || !IsClientInGame(iPlayer) || GetClientTeam(iPlayer) != 3 || IsFakeClient(iPlayer))
		{
			continue;
		}
		if (bIsPlayerGhost(iPlayer))
		{
			bResetGhostState[iPlayer] = true;
			vSetPlayerGhost(iPlayer, false);
			bResetAlive[iPlayer] = true; 
			vSetPlayerAlive(iPlayer, true);
		}
		else if (!IsPlayerAlive(iPlayer))
		{
			bResetLifeState[iPlayer] = true;
			vSetPlayerLifeState(iPlayer, false);
		}
	}
	Format(sOptions, sizeof(sOptions), "%s%s", sInfectedTypes[type], (auto ? " auto" : ""));
	bIsL4D2Game() ? vCheatCommand(client, "z_spawn_old", sOptions) : vCheatCommand(client, "z_spawn", sOptions);
	vKickFakeClient(client);
	for (int iPlayer = 1; iPlayer <= MaxClients; iPlayer++)
	{
		if (bResetGhostState[iPlayer])
		{
			vSetPlayerGhost(iPlayer, true);
		}
		if (bResetAlive[iPlayer])
		{
			vSetPlayerAlive(iPlayer, false);
		}
		if (bResetLifeState[iPlayer])
		{
			vSetPlayerLifeState(iPlayer, true);
		}
	}
}