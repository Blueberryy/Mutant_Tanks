#if defined _supertanks_included
	#endinput
#endif
#define _supertanks_included
#include <sourcemod>
#include <sdkhooks>
#include <sdktools>
#define ST_PREFIX "[ST++]"
#define ST_NAME "Super Tanks++"
#define ST_AUTHOR "Psyk0tik (Crasher_3637)"
#define ST_DESCRIPTION "Super Tanks++ makes fighting Tanks great again!"
#define ST_VERSION "8.11"
#define ST_URL "https://forums.alliedmods.net/showthread.php?t=302140"
#define ST_LOCK "=="
#define ST_UNLOCK "!="
#define ST_APPEND_BAD_FILENAME 0
#define ST_APPEND_FILE_NOT_FOUND 1
#define ST_APPEND_BAD_HANDLE 2
#define ST_APPEND_SUCCESS 3
#define ST_FIND_BAD_FILENAME 10
#define ST_FIND_FILE_NOT_FOUND 11
#define ST_FIND_BAD_HANDLE 12
#define ST_FIND_NOT_FOUND 13
#define ST_FIND_SUCCESS 14
#define ST_CLEAN_FILE_NOT_FOUND 20
#define ST_CLEAN_BAD_HANDLE 21
#define ST_CLEAN_SUCCESS 22
#define ST_NO_CONFIG 30
#define ST_FORMAT_BAD_FILENAME 40
#define ST_FORMAT_SUCCESS 41

// Configs
static bool g_bCreateDirectory;
static bool g_bCreateFile;
static char g_sConfigFile[PLATFORM_MAX_PATH];
static char g_sRawFileName[PLATFORM_MAX_PATH];
static char g_sFolderPath[PLATFORM_MAX_PATH];
static Handle g_hPluginHandle;
static int g_iCreateDirectoryMode;
static int g_iCurrentMode;
static int g_iLastFindResult;
static int g_iLastAppendResult;

stock int iST_GetFindResult()
{
	return g_iLastFindResult;
}

stock int iST_GetAppendResult()
{
	return g_iLastAppendResult;
}

stock void vST_CreateConfig(bool create)
{
	g_bCreateFile = create;
}

stock void vST_CreateDirectory(bool create, int mode = 511)
{
	g_bCreateDirectory = create;
	g_iCreateDirectoryMode = mode;
}

stock bool bST_GetCreateFile()
{
	return g_bCreateFile;
}

stock void vST_SetPlugin(Handle plugin)
{
	g_hPluginHandle = plugin;
}

stock Handle hST_GetPlugin()
{
	return g_hPluginHandle;
}

stock bool bST_Config(char[] file, char[] folder = "sourcemod/super_tanks++")
{
	Format(g_sConfigFile, sizeof(g_sConfigFile), "%s", file);
	strcopy(g_sRawFileName, sizeof(g_sRawFileName), file);
	strcopy(g_sFolderPath, sizeof(g_sFolderPath), folder);
	return iST_FormatConfig(g_sConfigFile, sizeof(g_sConfigFile), folder) == ST_FORMAT_SUCCESS;
}

stock bool bST_GetConfig(char[] buffer, int size)
{
	if (strlen(g_sConfigFile) > 0)
	{
		strcopy(buffer, size, g_sConfigFile);
		return true;
	}
	buffer[0] = '\0';
	return false;
}

stock ConVar cvST_ConVar(const char[] name, const char[] defaultValue, const char[] description = "", int flags = 0, bool hasMin = false, float min = 0.0, bool hasMax = false, float max = 0.0)
{
	if (!(flags & FCVAR_DONTRECORD) && strlen(g_sConfigFile) > 0)
	{
		g_iLastFindResult = -1;
		g_iLastAppendResult = -1;
		char sValue[64];
		g_iLastFindResult = iST_FindValue(name, sValue, sizeof(sValue), true);
		if (g_iLastFindResult == ST_FIND_NOT_FOUND || (g_iLastFindResult == ST_FIND_FILE_NOT_FOUND && g_bCreateFile))
		{
			g_iLastAppendResult = iST_Append(name, defaultValue, description, flags, hasMin, min, hasMax, max);
		}
	}
	return CreateConVar(name, defaultValue, description, flags, hasMin, min, hasMax, max);
}

stock void vST_ExecConfig()
{
	AutoExecConfig(!g_bCreateFile, g_sRawFileName, g_sFolderPath);
}

stock static int iST_FormatConfig(char[] buffer, int size, char[] folder = "sourcemod/super_tanks++")
{
	if (strlen(g_sConfigFile) < 1)
	{
		return ST_NO_CONFIG;
	}
	if (StrContains(g_sConfigFile, ".cfg") != -1 && strlen(g_sConfigFile) < 4)
	{
		return ST_FORMAT_BAD_FILENAME;
	}
	char sPathPrefix[PLATFORM_MAX_PATH];
	if (strlen(folder) > 0)
	{
		Format(sPathPrefix, sizeof(sPathPrefix), "cfg/%s/", folder);
		if (g_bCreateDirectory && !DirExists(sPathPrefix))
		{
			CreateDirectory(sPathPrefix, g_iCreateDirectoryMode);
		}
	}
	else
	{
		Format(sPathPrefix, sizeof(sPathPrefix), "cfg/");
	}
	char sFile[PLATFORM_MAX_PATH];
	sFile[0] = '\0';
	if (StrContains(buffer, sPathPrefix) != 0)
	{
		StrCat(sFile, sizeof(sFile), sPathPrefix);
	}
	StrCat(sFile, sizeof(sFile), g_sConfigFile);
	if (StrContains(sFile[strlen(sFile) - 4], ".cfg") != 0)
	{
		StrCat(sFile, sizeof(sFile), ".cfg");
	}
	strcopy(buffer, size, sFile);
	return ST_FORMAT_SUCCESS;
}

stock int iST_Append(const char[] name, const char[] defaultValue, const char[] description, int flags, bool hasMin, float min, bool hasMax, float max)
{
	if (strlen(g_sConfigFile) < 1)
	{
		return ST_NO_CONFIG;
	}
	char sFile[PLATFORM_MAX_PATH];
	strcopy(sFile, sizeof(sFile), g_sConfigFile);
	bool bFileExists = FileExists(sFile);
	if (g_bCreateFile || bFileExists)
	{
		File fFile = OpenFile(sFile, (bFileExists ? "a" : "w"));
		char sWrite[2048];
		if (fFile == null)
		{
			return ST_APPEND_BAD_HANDLE;
		}
		if (g_bCreateFile && !bFileExists)
		{
			fFile.WriteLine("// This file was auto-generated by Super Tanks++ v%s (%s)", ST_VERSION, ST_URL);
			GetPluginFilename(g_hPluginHandle, sWrite, sizeof(sWrite));
			Format(sWrite, sizeof(sWrite), "// ConVars for plugin \"%s\"", sWrite);
			fFile.WriteLine(sWrite);
		}
		fFile.WriteLine("\n");
		int iNewLines = iST_GetCharCountInStr('\n', description);
		if (iNewLines == 0)
		{
			Format(sWrite, sizeof(sWrite), "// %s", description);
			fFile.WriteLine(sWrite);
		}
		else
		{
			char[][] sNewLines = new char[iNewLines + 1][2048];
			ExplodeString(description, "\n", sNewLines, iNewLines + 1, 2048, false);
			for (int iLine; iLine <= iNewLines; iLine++)
			{
				if (strlen(sNewLines[iLine]) > 0)
				{
					fFile.WriteLine("// %s", sNewLines[iLine]);
				}
			}
		}
		fFile.WriteLine("// -");
		Format(sWrite, sizeof(sWrite), "// Default: \"%s\"", defaultValue);
		fFile.WriteLine(sWrite);
		if (hasMin)
		{		
			Format(sWrite, sizeof(sWrite), "// Minimum: \"%f\"", min);
			fFile.WriteLine(sWrite);
		}
		if (hasMax)
		{
			Format(sWrite, sizeof(sWrite), "// Maximum: \"%f\"", max);
			fFile.WriteLine(sWrite);
		}
		Format(sWrite, sizeof(sWrite), "%s \"%s\"", name, defaultValue);
		fFile.WriteLine(sWrite);
		delete fFile;		
		return ST_APPEND_SUCCESS;
	}
	return ST_APPEND_FILE_NOT_FOUND;
}

stock int iST_FindValue(const char[] cvar, char[] value, int size, bool caseSensitive = false)
{
	value[0] = '\0';
	if (strlen(g_sConfigFile) < 1)
	{
		return ST_NO_CONFIG;
	}
	char sFile[PLATFORM_MAX_PATH];
	strcopy(sFile, sizeof(sFile), g_sConfigFile);
	bool bFileExists = FileExists(sFile);
	if (g_bCreateFile && !bFileExists)
	{
		return ST_FIND_FILE_NOT_FOUND;
	}
	if (bFileExists)
	{
		File fFile = OpenFile(sFile, "r");
		int iValueStart;
		int iValueEnd;
		int iCvarEnd;
		char sConvar[64];
		char sValue[64];
		char sRead[2048];
		char sCopy[2048];
		if (fFile == null)
		{
			return ST_FIND_BAD_HANDLE;
		}
		while (!fFile.EndOfFile() && fFile.ReadLine(sRead, sizeof(sRead)))
		{
			if (IsCharSpace(sRead[0]) || sRead[0] == '/' || (!IsCharNumeric(sRead[0]) && !IsCharAlpha(sRead[0])) || iST_GetCharCountInStr(' ', sRead) < 1 || iST_GetCharCountInStr('"', sRead) != 2 || (iValueStart = StrContains(sRead, "\"")) == -1 || (iValueEnd = StrContains(sRead[iValueStart+1], "\"")) == -1 || (iCvarEnd = StrContains(sRead, " ")) == -1 || iCvarEnd >= iValueStart || iCvarEnd >= iValueStart)
			{
				continue;
			}
			strcopy(sCopy, sizeof(sCopy), sRead);
			sCopy[iCvarEnd] = '\0';
			strcopy(sConvar, sizeof(sConvar), sCopy);
			strcopy(sCopy, sizeof(sCopy), sRead[iValueStart+1]);
			sCopy[iValueEnd] = '\0';
			strcopy(sValue, sizeof(sValue), sCopy);
			if (StrEqual(sConvar, cvar, caseSensitive))
			{
				Format(value, size, "%s", sConvar);
				delete fFile;
				return ST_FIND_SUCCESS;
			}					
		}
		delete fFile;	
		return ST_FIND_NOT_FOUND;
	}
	return ST_FIND_FILE_NOT_FOUND;
}

stock int iST_Clean()
{
	if (strlen(g_sConfigFile) < 1)
	{
		return ST_NO_CONFIG;
	}
	char sFile[PLATFORM_MAX_PATH];
	strcopy(sFile, sizeof(sFile), g_sConfigFile);
	if (!FileExists(sFile))
	{
		return ST_CLEAN_FILE_NOT_FOUND;
	}
	char sFile2[PLATFORM_MAX_PATH];
	Format(sFile2, sizeof(sFile2), "%s_tempcopy", sFile);
	char sRead[2048];
	int iCount;
	bool bFirstReached;
	File fFile1 = OpenFile(sFile, "r");
	File fFile2 = OpenFile(sFile2, "w");
	if (fFile1 == null || fFile2 == null)
	{
		if (fFile1 != null)
		{
			delete fFile1;
		}
		if (fFile2 != null)
		{
			delete fFile2;
		}
		return ST_CLEAN_BAD_HANDLE;
	}
	while (!fFile1.EndOfFile() && fFile1.ReadLine(sRead, sizeof(sRead)))
	{
		if (IsCharSpace(sRead[0]))
		{
			iCount++;
		}
		else
		{
			iCount = 0;
		}
		if (iCount < 2 || !bFirstReached)
		{
			ReplaceString(sRead, sizeof(sRead), "\n", "");
			fFile2.WriteLine(sRead);
		}
		if (iCount == 2)
		{
			bFirstReached = true;
		}
	}
	delete fFile1;
	delete fFile2;
	DeleteFile(sFile);
	RenameFile(sFile, sFile2);	
	return ST_CLEAN_SUCCESS;
}

stock static int iST_GetCharCountInStr(int character, const char[] str)
{
	int iLength = strlen(str);
	int iCount;
	for (int iString; iString < iLength; iString++)
	{
		if (str[iString] == character)
		{
			iCount++;
		}
	}
	return iCount;
}

// Checks
public bool bBoomerFilter(const char[] pattern, Handle clients)
{
	for (int iPlayer = 1; iPlayer <= MaxClients; iPlayer++)
	{
		if (bIsBoomer(iPlayer))
		{
			PushArrayCell(clients, iPlayer);
		}
	}
	return true;
}

public bool bChargerFilter(const char[] pattern, Handle clients)
{
	for (int iPlayer = 1; iPlayer <= MaxClients; iPlayer++)
	{
		if (bIsCharger(iPlayer))
		{
			PushArrayCell(clients, iPlayer);
		}
	}
	return true;
}

stock bool bHasIdlePlayer(int client)
{
	int iIdler = GetClientOfUserId(GetEntData(client, FindSendPropInfo("SurvivorBot", "m_humanSpectatorUserID")));
	if (iIdler)
	{
		if (IsClientInGame(iIdler) && !IsFakeClient(iIdler) && (GetClientTeam(iIdler) != 2))
		{
			return true;
		}
	}
	return false;
}

public bool bHunterFilter(const char[] pattern, Handle clients)
{
	for (int iPlayer = 1; iPlayer <= MaxClients; iPlayer++)
	{
		if (bIsHunter(iPlayer))
		{
			PushArrayCell(clients, iPlayer);
		}
	}
	return true;
}

stock bool bIsBoomer(int client, bool alive = true)
{
	if (bIsInfected(client, alive))
	{
		if (GetEntProp(client, Prop_Send, "m_zombieClass") == 2)
		{
			return true;
		}
	}
	return false;
}

stock bool bIsBotIdle(int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2 && IsPlayerAlive(client) && !IsClientInKickQueue(client) && IsFakeClient(client) && bHasIdlePlayer(client);
}

stock bool bIsBotIdleSurvivor(int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2 && IsPlayerAlive(client) && !IsClientInKickQueue(client) && IsFakeClient(client) && !bHasIdlePlayer(client);
}

stock bool bIsBotInfected(int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3 && IsPlayerAlive(client) && !IsClientInKickQueue(client) && IsFakeClient(client);
}

stock bool bIsBotSurvivor(int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2 && IsPlayerAlive(client) && !IsClientInKickQueue(client) && IsFakeClient(client);
}

stock bool bIsCharger(int client, bool alive = true)
{
	if (bIsInfected(client, alive))
	{
		if (GetEntProp(client, Prop_Send, "m_zombieClass") == 6)
		{
			return true;
		}
	}
	return false;
}

stock bool bIsFinaleMap()
{
	return FindEntityByClassname(-1, "trigger_finale") != -1;
}

stock bool bIsHumanSurvivor(int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2 && IsPlayerAlive(client) && !IsClientInKickQueue(client) && !IsFakeClient(client) && !bHasIdlePlayer(client) && !bIsPlayerIdle(client);
}

stock bool bIsHunter(int client, bool alive = true)
{
	if (bIsInfected(client, alive))
	{
		if (GetEntProp(client, Prop_Send, "m_zombieClass") == 3)
		{
			return true;
		}
	}
	return false;
}

stock bool bIsIdlePlayer(int bot, int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && !IsFakeClient(client) && GetClientTeam(bot) == 2;
}

stock bool bIsInfected(int client, bool alive = true)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3 && (!alive || (alive && IsPlayerAlive(client))) && !IsClientInKickQueue(client);
}

stock bool bIsJockey(int client, bool alive = true)
{
	if (bIsInfected(client, alive))
	{
		if (bIsL4D2Game() && GetEntProp(client, Prop_Send, "m_zombieClass") == 5)
		{
			return true;
		}
	}
	return false;
}

stock bool bIsL4D2Game()
{
	return GetEngineVersion() == Engine_Left4Dead2;
}

stock bool bIsPlayerBurning(int client)
{
	float flBurnPercent = GetEntPropFloat(client, Prop_Send, "m_burnPercent");
	if (flBurnPercent > 0)
	{
		return true;
	}
	return false;
}

stock bool bIsPlayerGhost(int client)
{
	if (GetEntProp(client, Prop_Send, "m_isGhost", 1))
	{
		return true;
	}
	return false;
}

stock bool bIsPlayerIdle(int client)
{
	for (int iPlayer = 1; iPlayer <= MaxClients; iPlayer++)
	{
		if (!IsClientInGame(iPlayer) || GetClientTeam(iPlayer) != 2 || !IsFakeClient(iPlayer) || !bHasIdlePlayer(iPlayer))
		{
			continue;
		}
		int iIdler = GetClientOfUserId(GetEntData(iPlayer, FindSendPropInfo("SurvivorBot", "m_humanSpectatorUserID")));
		if (iIdler == client)
		{
			return true;
		}
	}
	return false;
}

stock bool bIsSmoker(int client, bool alive = true)
{
	if (bIsInfected(client, alive))
	{
		if (GetEntProp(client, Prop_Send, "m_zombieClass") == 1)
		{
			return true;
		}
	}
	return false;
}

stock bool bIsSpecialInfected(int client)
{
	if (bIsInfected(client))
	{
		int iClass = GetEntProp(client, Prop_Send, "m_zombieClass");
		if (iClass == 1 || iClass == 2 || iClass == 3 || iClass == 4 || (bIsL4D2Game() && iClass == 5) || iClass == 6)
		{
			return true;
		}
	}
	return false;
}

stock bool bIsSpitter(int client, bool alive = true)
{
	if (bIsInfected(client, alive))
	{
		if (GetEntProp(client, Prop_Send, "m_zombieClass") == 4)
		{
			return true;
		}
	}
	return false;
}

stock bool bIsSurvivor(int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2 && IsPlayerAlive(client) && !IsClientInKickQueue(client);
}

stock bool bIsSystemValid(ConVar convar, ConVar convar2, ConVar convar3, ConVar convar4)
{
	if (convar == null)
	{
		return false;
	}
	if (convar4.IntValue != 0)
	{
		g_iCurrentMode = 0;
		int iMode = CreateEntityByName("info_gamemode");
		DispatchSpawn(iMode);
		HookSingleEntityOutput(iMode, "OnCoop", vGamemode, true);
		HookSingleEntityOutput(iMode, "OnSurvival", vGamemode, true);
		HookSingleEntityOutput(iMode, "OnVersus", vGamemode, true);
		HookSingleEntityOutput(iMode, "OnScavenge", vGamemode, true);
		ActivateEntity(iMode);
		AcceptEntityInput(iMode, "PostSpawnActivate");
		AcceptEntityInput(iMode, "Kill");
		if (g_iCurrentMode == 0 || !(convar4.IntValue & g_iCurrentMode))
		{
			return false;
		}
	}
	char sGameMode[32];
	char sConVarModes[32];
	convar.GetString(sGameMode, sizeof(sGameMode));
	Format(sGameMode, sizeof(sGameMode), ",%s,", sGameMode);
	convar2.GetString(sConVarModes, sizeof(sConVarModes));
	if (strcmp(sConVarModes, ""))
	{
		Format(sConVarModes, sizeof(sConVarModes), ",%s,", sConVarModes);
		if (StrContains(sConVarModes, sGameMode, false) == -1)
		{
			return false;
		}
	}
	convar3.GetString(sConVarModes, sizeof(sConVarModes));
	if (strcmp(sConVarModes, ""))
	{
		Format(sConVarModes, sizeof(sConVarModes), ",%s,", sConVarModes);
		if (StrContains(sConVarModes, sGameMode, false) != -1)
		{
			return false;
		}
	}
	return true;
}

stock bool bIsTank(int client, bool alive = true)
{
	if (bIsInfected(client, alive))
	{
		int iClass = GetEntProp(client, Prop_Send, "m_zombieClass");
		if ((bIsL4D2Game() && iClass == 8) || (!bIsL4D2Game() && iClass == 5))
		{
			return true;
		}
	}
	return false;
}

stock bool bIsValidClient(int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && !IsClientInKickQueue(client);
}

stock bool bIsValidHumanClient(int client)
{
	return client > 0 && client <= MaxClients && IsClientInGame(client) && !IsClientInKickQueue(client) && !IsFakeClient(client);
}

stock bool bIsValidEntRef(int entity)
{
	return entity && EntRefToEntIndex(entity) != INVALID_ENT_REFERENCE;
}

public bool bJockeyFilter(const char[] pattern, Handle clients)
{
	for (int iPlayer = 1; iPlayer <= MaxClients; iPlayer++)
	{
		if (bIsJockey(iPlayer))
		{
			PushArrayCell(clients, iPlayer);
		}
	}
	return true;
}

public bool bSmokerFilter(const char[] pattern, Handle clients)
{
	for (int iPlayer = 1; iPlayer <= MaxClients; iPlayer++)
	{
		if (bIsSmoker(iPlayer))
		{
			PushArrayCell(clients, iPlayer);
		}
	}
	return true;
}

public bool bSpitterFilter(const char[] pattern, Handle clients)
{
	for (int iPlayer = 1; iPlayer <= MaxClients; iPlayer++)
	{
		if (bIsSpitter(iPlayer))
		{
			PushArrayCell(clients, iPlayer);
		}
	}
	return true;
}

public bool bTankFilter(const char[] pattern, Handle clients)
{
	for (int iPlayer = 1; iPlayer <= MaxClients; iPlayer++)
	{
		if (bIsTank(iPlayer))
		{
			PushArrayCell(clients, iPlayer);
		}
	}
	return true;
}

public bool bTraceRayDontHitSelf(int entity, int mask, any data)
{
	if (entity == data) 
	{
		return false; 
	}
	else if (entity > 0 && entity <= MaxClients)
	{
		if (IsClientInGame(entity))
		{
			return false;
		}
	}
	return true;
}

// Functions
public float flGetGroundUnits(int entity)
{
	if (!(GetEntityFlags(entity) & FL_ONGROUND))
	{ 
		Handle hTrace;
		float flOrigin[3];
		float flPosition[3];
		float flDown[3] = {90.0, 0.0, 0.0};
		GetEntPropVector(entity, Prop_Send, "m_vecOrigin", flOrigin);
		hTrace = TR_TraceRayFilterEx(flOrigin, flDown, CONTENTS_SOLID|CONTENTS_MOVEABLE, RayType_Infinite, bTraceRayDontHitSelf, entity);
		if (TR_DidHit(hTrace))
		{
			float flUnits;
			TR_GetEndPosition(flPosition, hTrace);
			flUnits = flOrigin[2] - flPosition[2];
			delete hTrace;
			return flUnits;
		}
		delete hTrace;
	}
	return 0.0;
}

stock int iGetAccurateTime(ConVar convar, const bool difference = true)
{
	if (!difference)
	{
		return GetTime();
	}
	int iTime = GetTime();
	int iOperand = iParseTimeOffsetOperation(convar, false);
	int iAmount = iParseTimeOffsetOperation(convar, true);
	if (iOperand == '+')
	{
		iTime = iTime + (iAmount * 3600);
	}
	if (iOperand == '-')
	{
		iTime = iTime - (iAmount * 3600);
	}
	return iTime;
}

stock int iGetBotSurvivor()
{
	for (int iBot = MaxClients; iBot >= 1; iBot--)
	{
		if (bIsBotSurvivor(iBot))
		{
			return iBot;
		}
	}
	return -1;
}

stock int iGetHumanCount()
{
	int iHumanCount;
	for (int iHuman = 1; iHuman <= MaxClients; iHuman++)
	{
		if (bIsHumanSurvivor(iHuman))
		{
			iHumanCount++;
		}
	}
	return iHumanCount;
}

stock int iGetIdleBot(int client)
{
	for (int iBot = 1; iBot <= MaxClients; iBot++)
	{
		if (iGetIdlePlayer(iBot) == client)
		{
			return iBot;
		}
	}
	return 0;
}

stock int iGetIdlePlayer(int client)
{
	if (bIsBotSurvivor(client))
	{
		char sClassname[12];
		GetEntityNetClass(client, sClassname, sizeof(sClassname));
		if (strcmp(sClassname, "SurvivorBot") == 0)
		{
			int iIdler = GetClientOfUserId(GetEntProp(client, Prop_Send, "m_humanSpectatorUserID"));			
			if (iIdler > 0 && IsClientInGame(iIdler) && GetClientTeam(iIdler) == 1)
			{
				return iIdler;
			}
		}
	}
	return 0;
}

stock int iGetInfectedCount()
{
	int iInfectedCount;
	for (int iInfected = 1; iInfected <= MaxClients; iInfected++)
	{
		if (bIsInfected(iInfected))
		{
			iInfectedCount++;
		}
	}
	return iInfectedCount;
}

stock int iGetNearestSurvivor(int client)
{
	float flDistance = 0.0;
	float flNearest = 0.0;
	float flPlayerPos[3];
	float flTargetPos[3];
	if (bIsValidClient(client))
	{
		GetClientAbsOrigin(client, flPlayerPos);
		for (int iSurvivor = 1; iSurvivor <= MaxClients; iSurvivor++)
		{
			if (bIsSurvivor(iSurvivor))
			{
				GetClientAbsOrigin(iSurvivor, flTargetPos);
				flDistance = GetVectorDistance(flPlayerPos, flTargetPos);
				if (flNearest == 0.0 || flNearest > flDistance)
				{
					flNearest = flDistance;
				}
			}
		}
	}
	return RoundFloat(flDistance);
}

stock int iGetPlayerCount()
{
	int iPlayerCount;
	for (int iPlayer = 1; iPlayer <= MaxClients; iPlayer++)
	{
		if (bIsValidHumanClient(iPlayer))
		{
			iPlayerCount++;
		}
	}
	return iPlayerCount;
}

stock int iGetRandomSurvivor()
{
    int iSurvivorCount;
    int iSurvivors[MAXPLAYERS + 1];
    for (int iSurvivor = 1; iSurvivor <= MaxClients; iSurvivor++)
    {
        if (bIsSurvivor(iSurvivor))
        {
            iSurvivors[iSurvivorCount++] = iSurvivor; 
        }
    }
    return iSurvivors[GetRandomInt(0, iSurvivorCount - 1)];
}

stock int iGetRayHitPos(float pos[3], float angle[3], float hitpos[3], int entity = 0, bool offset = false)
{
	int iHit = 0;
	Handle hTrace = TR_TraceRayFilterEx(pos, angle, MASK_SOLID, RayType_Infinite, bTraceRayDontHitSelf, entity);
	if (TR_DidHit(hTrace))
	{
		TR_GetEndPosition(hitpos, hTrace);
		iHit = TR_GetEntityIndex(hTrace);
	}
	delete hTrace;
	if (offset)
	{
		float flVector[3];
		MakeVectorFromPoints(hitpos, pos, flVector);
		NormalizeVector(flVector, flVector);
		ScaleVector(flVector, 15.0);
		AddVectors(hitpos, flVector, hitpos);
	}
	return iHit;
}

stock int iGetRGBColor(int red, int green, int blue) 
{
	return (blue * 65536) + (green * 256) + red;
}

stock int iGetSurvivorCount()
{
	int iSurvivorCount;
	for (int iSurvivor = 1; iSurvivor <= MaxClients; iSurvivor++)
	{
		if (bIsSurvivor(iSurvivor))
		{
			iSurvivorCount++;
		}
	}
	return iSurvivorCount;
}

stock int iGetSurvivorRange(int client)
{
	int iSurvivorCount;
	for (int iSurvivor = 1; iSurvivor <= MaxClients; iSurvivor++)
	{
		if (bIsSurvivor(iSurvivor))
		{
			float flPlayerPos[3];
			float flTankPos[3];
			GetClientAbsOrigin(iSurvivor, flPlayerPos);
			GetClientAbsOrigin(client, flTankPos);
			float flDistance = GetVectorDistance(flTankPos, flPlayerPos);
			if (flDistance > 120)
			{
				iSurvivorCount++;
			}
		}
	}
	return iSurvivorCount;
}

stock int iGetTankCount()
{
	int iTankCount;
	for (int iTank = 1; iTank <= MaxClients; iTank++)
	{
		if (bIsTank(iTank))
		{
			iTankCount++;
		}
	}
	return iTankCount;
}

stock int iParseTimeOffsetOperation(ConVar convar, const bool operation = false)
{
	char sConvarValue[16];
	convar.GetString(sConvarValue, sizeof(sConvarValue));
	TrimString(sConvarValue);
	int iOperand = sConvarValue[0];
	sConvarValue[0] = ' ';
	TrimString(sConvarValue);
	int iAmount = StringToInt(sConvarValue);
	if (iOperand != '+' && iOperand != '-' && (iAmount <= 0 || iAmount > 24))
	{
		iOperand = ' ';
		iAmount  = 0;
	}
	return operation ? iAmount : iOperand;
}

stock void vCheatCommand(int client, char[] command, char[] arguments = "")
{
	int iCmdFlags = GetCommandFlags(command);
	SetCommandFlags(command, iCmdFlags & ~FCVAR_CHEAT);
	FakeClientCommand(client, "%s %s", command, arguments);
	SetCommandFlags(command, iCmdFlags | FCVAR_CHEAT);
}

stock void vCopyVector(float source[3], float target[3])
{
	target[0] = source[0];
	target[1] = source[1];
	target[2] = source[2];
}

stock void vDeleteEntity(int entity, float time)
{
	if (bIsValidEntRef(entity))
	{
		char sVariant[64];
		Format(sVariant, sizeof(sVariant), "OnUser1 !self:kill::%f:1", time);
		SetVariantString(sVariant);
		AcceptEntityInput(entity, "AddOutput");
		AcceptEntityInput(entity, "FireUser1");
	}
}

stock void vDeleteExplosion(int entity, float time, char[] input)
{
	if (bIsValidEntRef(entity))
	{
		char sVariant[64];
		Format(sVariant, sizeof(sVariant), "OnUser1 !self:kill::%f:1", time);
		SetVariantString(sVariant);
		AcceptEntityInput(entity, input);
	}
}

public void vGamemode(const char[] output, int caller, int activator, float delay)
{
	if (strcmp(output, "OnCoop") == 0)
	{
		g_iCurrentMode = 1;
	}
	else if (strcmp(output, "OnSurvival") == 0)
	{
		g_iCurrentMode = 2;
	}
	else if (strcmp(output, "OnVersus") == 0)
	{
		g_iCurrentMode = 4;
	}
	else if (strcmp(output, "OnScavenge") == 0)
	{
		g_iCurrentMode = 8;
	}
}

stock void vKickFakeClient(int client)
{
	if (IsFakeClient(client))
	{
		KickClient(client);
	}
}

stock void vMultiTargetFilters(int toggle)
{
	switch (toggle)
	{
		case 0:
		{
			RemoveMultiTargetFilter("@smokers", bSmokerFilter);
			RemoveMultiTargetFilter("@boomers", bBoomerFilter);
			RemoveMultiTargetFilter("@hunters", bHunterFilter);
			RemoveMultiTargetFilter("@spitters", bSpitterFilter);
			RemoveMultiTargetFilter("@jockeys", bJockeyFilter);
			RemoveMultiTargetFilter("@chargers", bChargerFilter);
			RemoveMultiTargetFilter("@tanks", bTankFilter);
		}
		case 1:
		{
			AddMultiTargetFilter("@smokers", bSmokerFilter, "all Smokers", false);
			AddMultiTargetFilter("@boomers", bBoomerFilter, "all Boomers", false);
			AddMultiTargetFilter("@hunters", bHunterFilter, "all Hunters", false);
			AddMultiTargetFilter("@spitters", bSpitterFilter, "all Spitters", false);
			AddMultiTargetFilter("@jockeys", bJockeyFilter, "all Jockeys", false);
			AddMultiTargetFilter("@chargers", bChargerFilter, "all Chargers", false);
			AddMultiTargetFilter("@tanks", bTankFilter, "all Tanks", false);
		}
	}
}

stock void vSetPlayerAlive(int client, bool alive)
{
	alive ? SetEntData(client, FindSendPropInfo("CTransitioningPlayer", "m_isAlive"), 1, 1, true) : SetEntData(client, FindSendPropInfo("CTransitioningPlayer", "m_isAlive"), 0, 1, true);
}

stock void vSetPlayerGhost(int client, bool ghost)
{
	ghost ? SetEntProp(client, Prop_Send, "m_isGhost", 1, 1) : SetEntProp(client, Prop_Send, "m_isGhost", 0, 1);
}

stock void vSetPlayerLifeState(int client, bool ready)
{
	ready ? SetEntProp(client, Prop_Data, "m_lifeState", 1, 1) : SetEntProp(client, Prop_Data, "m_lifeState", 0, 1);
}

stock void vSetVector(float target[3], float x, float y, float z)
{
	target[0] = x;
	target[1] = y;
	target[2] = z;
}

stock void vSpawnInfected(int client, int type, bool auto = true)
{
	bool bResetGhostState[MAXPLAYERS + 1];
	bool bResetAlive[MAXPLAYERS + 1];
	bool bResetLifeState[MAXPLAYERS + 1];
	ChangeClientTeam(client, 3);
	char sInfectedTypes[10][10] = {"", "smoker", "boomer", "hunter", "spitter", "jockey", "charger", "witch", "tank", "survivor"};
	char sOptions[32];
	if (type < 1 || type > 8 || !IsClientInGame(client) || GetClientTeam(client) != 3 || IsPlayerAlive(client))
	{
		return;
	}
	for (int iPlayer = 1; iPlayer <= MaxClients; iPlayer++)
	{ 
		if (iPlayer == client || !IsClientInGame(iPlayer) || GetClientTeam(iPlayer) != 3 || IsFakeClient(iPlayer))
		{
			continue;
		}
		if (bIsPlayerGhost(iPlayer))
		{
			bResetGhostState[iPlayer] = true;
			vSetPlayerGhost(iPlayer, false);
			bResetAlive[iPlayer] = true; 
			vSetPlayerAlive(iPlayer, true);
		}
		else if (!IsPlayerAlive(iPlayer))
		{
			bResetLifeState[iPlayer] = true;
			vSetPlayerLifeState(iPlayer, false);
		}
	}
	Format(sOptions, sizeof(sOptions), "%s%s", sInfectedTypes[type], (auto ? " auto" : ""));
	bIsL4D2Game() ? vCheatCommand(client, "z_spawn_old", sOptions) : vCheatCommand(client, "z_spawn", sOptions);
	vKickFakeClient(client);
	for (int iPlayer = 1; iPlayer <= MaxClients; iPlayer++)
	{
		if (bResetGhostState[iPlayer])
		{
			vSetPlayerGhost(iPlayer, true);
		}
		if (bResetAlive[iPlayer])
		{
			vSetPlayerAlive(iPlayer, false);
		}
		if (bResetLifeState[iPlayer])
		{
			vSetPlayerLifeState(iPlayer, true);
		}
	}
}